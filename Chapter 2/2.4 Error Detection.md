# 🧭 2.4 Error Detection

Even the most reliable links can occasionally introduce bit errors caused by interference, noise, or signal distortion.  
Error detection mechanisms ensure corrupted data is identified so it can be retransmitted or corrected before it causes larger problems.

---

## 🔑 Key Points

### 1. Why Error Detection Matters
Errors are rare but inevitable—especially due to electrical interference or thermal noise.  
Even a single corrupted bit can alter a file or message (e.g., turning valid code into invalid syntax).  
Networks use redundant bits to help detect (and sometimes correct) such errors efficiently.

---

### 2. Two Main Approaches

| Approach | Description |
|-----------|--------------|
| **Error Detection + Retransmission** | Receiver detects error → discards the message → requests sender to resend. Common in most networks. |
| **Error Correction (FEC)** | Receiver detects and fixes certain errors automatically using redundant bits. Common in wireless/satellite systems. |

---

### 3. Core Principle
Sender and receiver share a known algorithm.  

1. Sender applies algorithm → generates redundant “check” bits → sends both data and code.  
2. Receiver recalculates and compares:  
   - **Match:** data is valid.  
   - **Mismatch:** data is corrupted → discard or request retransmission.  

These redundant bits are called **error-detecting codes**.

---

### 4. Checksum vs. CRC

| Type | Based On | Typical Use | Strength |
|------|-----------|-------------|-----------|
| **Checksum** | Addition | Software-level (TCP, UDP, IP) | Simple, weaker |
| **CRC (Cyclic Redundancy Check)** | Polynomial division | Link-level (Ethernet, Wi-Fi) | Stronger, hardware-efficient |

---

## ⚙️ 2.4.1 Internet Checksum Algorithm

### Overview
A simple software-based error detection method using ones’ complement arithmetic.

### Process
1. Divide data into 16-bit words.  
2. Add all words using ones’ complement arithmetic (wrap carry bits around).  
3. Take the ones’ complement of the final sum → this is the checksum.  
4. Receiver repeats calculation and compares its result with the transmitted checksum.

### Ones’ Complement Arithmetic
Negative numbers are represented by inverting bits (e.g., +5 = 0101, -5 = 1010).  
When adding, a carryout from the most significant bit wraps around and is added back to the result.

### Example (Simplified)
```c
u_short cksum(u_short *buf, int count) {
    u_long sum = 0;
    while (count--) {
        sum += *buf++;
        if (sum & 0xFFFF0000) { // carry occurred
            sum = (sum & 0xFFFF) + 1;
        }
    }
    return ~(sum & 0xFFFF);
}
